<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#f5f5f7">
    <meta name="description" content="Kopī is a world-class shape matching puzzle game designed for mindfulness. Immerse yourself in a relaxing, high-fidelity experience with glassmorphism aesthetics.">
    <meta name="keywords" content="puzzle, shape matching, game, relaxing, brain training, glassmorphism, web game, mindfulness, meditation, zen, stress relief, interactive art">
    <meta name="author" content="Kopī Interactive">

    <!-- Social & Open Graph -->
    <meta property="og:title" content="Kopī - A Mindful Shape Matching Experience">
    <meta property="og:description" content="Find your flow. Immerse yourself in a world of shapes, colors, and satisfying physics. A relaxing, high-fidelity puzzle game for your mind.">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Kopī">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Kopī - Find Your Flow">
    <meta name="twitter:description" content="A relaxing, high-fidelity puzzle game designed for mindfulness.">

    <title>Kopī | Relaxing Shape Puzzle & Mindfulness Experience</title>

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Kopī",
      "description": "A world-class shape matching puzzle game designed for mindfulness and relaxation.",
      "genre": ["Puzzle", "Casual", "Mindfulness"],
      "operatingSystem": "Web Browser",
      "applicationCategory": "Game",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Organization",
        "name": "Kopī Interactive"
      }
    }
    </script>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='8' y='8' width='40' height='40' rx='10' fill='%23007AFF' /%3E%3Ccircle cx='44' cy='44' r='18' fill='%23FF2D55' /%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            /* World Class Color Palette */
            --bg-primary: #f5f5f7;
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;

            /* Vibrant, Tactile Colors - P3 Gamut inspired */
            --color-blue: #007AFF;
            --color-pink: #FF2D55;
            --color-green: #34C759;
            --color-yellow: #FFCC00;

            /* Deep, layered shadows for depth */
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04), 0 1px 2px rgba(0,0,0,0.06);
            --shadow-md: 0 12px 24px -6px rgba(0,0,0,0.08), 0 4px 8px -4px rgba(0,0,0,0.04);
            --shadow-lg: 0 24px 48px -12px rgba(0,0,0,0.12), 0 12px 24px -8px rgba(0,0,0,0.04);
            --shadow-float: 0 30px 60px -12px rgba(50, 50, 93, 0.25), 0 18px 36px -18px rgba(0, 0, 0, 0.3);

            --shadow-inner: inset 0 1px 1px rgba(255,255,255,0.5), inset 0 -2px 5px rgba(0,0,0,0.05);
            --shadow-glass: 0 8px 32px 0 rgba(31, 38, 135, 0.07);

            --radius-md: 20px;
            --radius-lg: 36px;
            --radius-full: 999px;

            /* Animation curves */
            --ease-elastic: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-smooth: cubic-bezier(0.2, 0.0, 0.2, 1.0);
            --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.35);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f7;
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Noise Texture for Texture/Premium Feel */
        .noise-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9000;
            opacity: 0.035;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* Subtle animated background mesh */
        body::before {
            content: '';
            position: absolute;
            width: 140%;
            height: 140%;
            background: radial-gradient(circle at 50% 10%, rgba(0,122,255,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 90% 60%, rgba(255,45,85,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 10% 70%, rgba(52,199,89,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 80% 20%, rgba(255,204,0,0.05) 0%, transparent 30%);
            top: -20%;
            left: -20%;
            z-index: -1;
            animation: floatBg 20s ease-in-out infinite alternate;
            will-change: transform;
        }

        @keyframes floatBg {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(-2%, 2%) scale(1.05); }
        }

        /* Layout Container */
        .app-container {
            width: 100%;
            height: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            padding: 24px;
            position: relative;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 4px;
            margin-bottom: 16px;
            z-index: 10;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -1px;
            color: var(--text-primary);
            opacity: 0.9;
        }

        .level-badge {
            background: rgba(255, 255, 255, 0.5);
            padding: 8px 16px;
            border-radius: var(--radius-full);
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-sm);
            letter-spacing: -0.3px;
            transition: transform 0.3s var(--ease-spring);
        }

        .btn-sound {
            background: rgba(255, 255, 255, 0.5);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-sm);
            color: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .btn-sound:active {
            transform: scale(0.9);
        }

        .btn-sound svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Game Area */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
            /* Provide some padding for the floating elements */
            padding: 20px 0;
        }

        .canvas-container {
            width: 100%;
            max-width: 420px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.45);
            /* Subtle dot pattern */
            background-image: radial-gradient(rgba(0,0,0,0.06) 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md), inset 0 0 0 1px rgba(255,255,255,0.6);
            position: relative;
            overflow: hidden;
            transition: transform 0.4s var(--ease-smooth);
        }

        /* Mobile Optimization */
        @media (max-width: 480px) {
            .app-container { padding: 16px; }
            .canvas-container { width: 92vw; border-radius: 28px; }
            .palette { border-radius: 28px; gap: 16px; padding: 16px; }
        }

        /* Palette (Dock) */
        .palette {
            margin-top: auto;
            width: 100%;
            min-height: 110px;
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-lg);
            padding: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            box-shadow: var(--shadow-lg), inset 0 0 0 1px rgba(255,255,255,0.5);
            position: relative;
            z-index: 20;
            margin-bottom: 24px;
            transition: transform 0.3s ease;
        }

        /* Empty State for Palette */
        .palette:empty::after {
            content: 'All Placed';
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            opacity: 0.5;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        /* Palette Slots */
        .palette-slot {
            width: 64px;
            height: 64px;
            border-radius: 16px;
            background: rgba(0,0,0,0.03);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
        }

        .palette-slot::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            border: 1px dashed rgba(0,0,0,0.1);
        }

        /* Shapes */
        .shape {
            width: 64px;
            height: 64px;
            position: absolute;
            will-change: transform;
            /* Default transform for centering if needed, but we position by top/left % */
        }

        /* Shape Rendering */
        .shape-render {
            width: 100%;
            height: 100%;
            /* Squircle approximation */
            border-radius: 22%;
            transition: transform 0.4s var(--ease-elastic), opacity 0.2s ease, filter 0.2s ease, box-shadow 0.3s ease;
            box-shadow: var(--shadow-inner), 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        /* Add a subtle sheen to shapes */
        .shape-render::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .shape.in-palette {
            position: relative;
            cursor: grab;
            touch-action: none;
            transition: transform 0.3s var(--ease-spring);
            z-index: 10;
        }

        /* Desktop Hover: Juicy scale and tilt handled by CSS for initial feel */
        @media (hover: hover) {
            .shape.in-palette:hover {
                transform: translateY(-8px) scale(1.1);
                z-index: 20;
            }
            .shape.in-palette:hover .shape-render {
                box-shadow: var(--shadow-float), var(--shadow-inner);
            }
        }

        .shape.in-palette:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .shape.in-palette .shape-render {
            box-shadow: 0 4px 10px rgba(0,0,0,0.1), var(--shadow-inner);
        }

        .shape.in-palette.dragging {
            opacity: 0.0; /* Fully hide original when dragging for better illusion */
        }

        /* Shape Types */
        .type-circle .shape-render { border-radius: 50%; }

        .type-triangle .shape-render {
            clip-path: polygon(50% 10%, 10% 85%, 90% 85%);
            border-radius: 0;
            box-shadow: none;
            background-color: transparent !important; /* Fix for bg bleed */
            /* Use filter for drop shadow on clipped shapes */
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
        }
        /* Triangle sheen fix */
        .type-triangle .shape-render::after {
            background: linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 60%);
        }

        /* Colors with slight gradient for depth */
        .color-blue .shape-render { background: linear-gradient(145deg, #2b95ff, #0066d6); }
        .color-pink .shape-render { background: linear-gradient(145deg, #ff5274, #e01640); }
        .color-green .shape-render { background: linear-gradient(145deg, #5ddb7d, #24b348); }
        .color-yellow .shape-render { background: linear-gradient(145deg, #ffd633, #eebb00); }

        /* Targets */
        .target {
            position: absolute;
            width: 64px;
            height: 64px;
            opacity: 1; /* Handle opacity in children */
            transform-origin: center;
            transition: transform 0.3s var(--ease-smooth);
        }

        .target .shape-render {
            background: rgba(0,0,0,0.04);
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            border: 2px solid rgba(0,0,0,0.05);
        }

        .target .shape-render::after { display: none; } /* No sheen on targets */

        .target.highlight .shape-render {
            background: rgba(0,0,0,0.08);
            border-color: rgba(0,0,0,0.1);
            transform: scale(1.1);
        }

        /* Placed Shape */
        .shape.placed {
            pointer-events: none;
        }
        .shape.placed .shape-render {
            animation: popIn 0.5s var(--ease-elastic) forwards;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Drag Ghost */
        .drag-ghost {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
            will-change: transform;
            width: 64px;
            height: 64px;
            margin-left: -32px; /* Center on pointer */
            margin-top: -32px;
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.25));
        }

        .drag-ghost .shape-render {
            transform: scale(1.15); /* Slightly larger while dragging */
        }

        /* Overlay */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 50;
            border-radius: var(--radius-lg);
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay h2 {
            font-size: 32px;
            margin: 0 0 8px 0;
            background: linear-gradient(135deg, #1d1d1f 0%, #4a4a4f 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s var(--ease-smooth);
        }

        .overlay.visible h2 {
            transform: translateY(0);
            opacity: 1;
        }

        .star-rating {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.6s var(--ease-spring) 0.2s;
        }

        .overlay.visible .star-rating {
            opacity: 1;
            transform: scale(1);
        }

        .star {
            font-size: 28px;
            color: #FFCC00;
            filter: drop-shadow(0 2px 4px rgba(255, 204, 0, 0.3));
            animation: starPop 0.4s var(--ease-elastic) backwards;
        }

        .overlay.visible .star:nth-child(1) { animation-delay: 0.3s; }
        .overlay.visible .star:nth-child(2) { animation-delay: 0.4s; }
        .overlay.visible .star:nth-child(3) { animation-delay: 0.5s; }

        @keyframes starPop {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .level-stats {
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 24px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.5s ease 0.4s;
        }

        .overlay.visible .level-stats {
            opacity: 0.75;
            transform: translateY(0);
        }

        .win-quote {
            font-size: 16px;
            font-style: italic;
            color: var(--text-primary);
            max-width: 80%;
            text-align: center;
            margin: 8px 0 24px 0;
            line-height: 1.5;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.5s ease 0.3s;
        }

        .overlay.visible .win-quote {
            opacity: 0.85;
            transform: translateY(0);
        }

        .overlay-controls {
            display: flex;
            gap: 16px;
            align-items: center;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s var(--ease-smooth) 0.1s;
        }

        .overlay.visible .overlay-controls {
            transform: translateY(0);
            opacity: 1;
        }

        .btn-next {
            background: var(--text-primary);
            color: white;
            border: none;
            padding: 14px 32px;
            font-size: 16px;
            font-weight: 600;
            border-radius: var(--radius-full);
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }

        .btn-icon {
            background: rgba(255,255,255,0.8);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            color: var(--text-primary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .btn-icon:hover {
            transform: scale(1.05);
            background: #fff;
        }
        
        .btn-icon svg { width: 24px; height: 24px; fill: currentColor; }

        /* Shake Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-6px); }
            40% { transform: translateX(6px); }
            60% { transform: translateX(-3px); }
            80% { transform: translateX(3px); }
        }
        
        .shake-element {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        .tutorial-hint {
            position: absolute;
            bottom: 24px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .tutorial-hint.visible {
            opacity: 0.8;
            transform: translateY(0);
        }

        /* Animated Hand Cursor */
        .hand-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' style='filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));'%3E%3Cpath d='M9 2c-.55 0-1 .45-1 1v7.68l-2.48-.95c-.32-.12-.67-.03-.9.23l-.76.84 5.39 5.39c.31.31.73.49 1.17.49h6.14c.78 0 1.44-.56 1.57-1.33l.91-5.46c.03-.19.05-.38.05-.58 0-1.66-1.34-3-3-3H11V3c0-.55-.45-1-1-1z' fill='%231d1d1f'/%3E%3C/svg%3E") no-repeat center/contain;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .hand-cursor.animating {
            animation: handMove 2s infinite ease-in-out;
            opacity: 1;
        }

        @keyframes handMove {
            0% { transform: translate(30%, 150%) scale(1); }
            20% { transform: translate(30%, 150%) scale(0.9); }
            50% { transform: translate(150%, 50%) scale(0.9); }
            80% { transform: translate(150%, 50%) scale(1); }
            100% { transform: translate(30%, 150%) scale(1); }
        }

        /* Floating Feedback Text */
        .feedback-text {
            position: absolute;
            font-size: 20px;
            font-weight: 700;
            color: var(--color-blue);
            pointer-events: none;
            z-index: 500;
            animation: floatUp 1s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            text-shadow: 0 2px 10px rgba(255,255,255,0.8);
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -100%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -250%) scale(1); opacity: 0; }
        }

    </style>
</head>
<body>
<div class="noise-overlay"></div>
<div class="app-container">
    <header class="header">
        <div class="logo">Kopī</div>
        <div class="header-controls">
            <div class="level-badge" id="level-display">Level 1</div>
            <button class="btn-sound" id="btn-sound" aria-label="Toggle Sound" title="Toggle Sound">
                <svg viewBox="0 0 24 24">
                    <path d="M14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77zm-4 0c-4.01.91-7 4.49-7 8.77s2.99 7.86 7 8.77v-2.06c-2.89-.86-5-3.54-5-6.71s2.11-5.85 5-6.71V3.23zM3 9v6h4l5 5V4L7 9H3z"/>
                </svg>
            </button>
        </div>
    </header>

    <div class="game-area">
        <div class="canvas-container" id="canvas-container">
            <div id="game-canvas" style="width: 100%; height: 100%; position: relative;"></div>

            <div class="tutorial-hint" id="tutorial-hint">Drag shapes to match</div>

            <div class="overlay" id="completion-overlay">
                <h2 id="win-title">Perfect</h2>
                <div class="star-rating">
                    <div class="star">★</div><div class="star">★</div><div class="star">★</div>
                </div>
                <div class="level-stats" id="win-stats">Excellent Flow</div>
                <div class="overlay-controls">
                    <button class="btn-icon" id="btn-replay" aria-label="Replay Level" title="Replay Level">
                        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </button>
                    <button class="btn-next" id="btn-next" title="Next Level">Continue</button>
                </div>
            </div>
        </div>
    </div>

    <div class="palette" id="palette">
        <!-- Palette Items Generated Here -->
    </div>
</div>

<script>
/**
 * Kopī - World Class UX Polish
 * Optimized for Touch (Mobile) and Mouse (Desktop)
 */

(() => {
const LEVELS = [
    {
        title: "The Beginning",
        subtitle: "Every journey begins with a single step.",
        shapes: [
            { id: 1, type: 'square', color: 'blue', x: 30, y: 50 },
            { id: 2, type: 'circle', color: 'pink', x: 70, y: 50 }
        ]
    },
    {
        title: "Balance",
        subtitle: "Find your center.",
        shapes: [
            { id: 1, type: 'triangle', color: 'green', x: 50, y: 30, rotation: 0 },
            { id: 2, type: 'square', color: 'yellow', x: 30, y: 70 },
            { id: 3, type: 'circle', color: 'blue', x: 70, y: 70 }
        ]
    },
    {
        title: "Reflection",
        subtitle: "Look within.",
        shapes: [
            { id: 1, type: 'square', color: 'pink', x: 25, y: 25 },
            { id: 2, type: 'square', color: 'pink', x: 75, y: 75 },
            { id: 3, type: 'circle', color: 'green', x: 75, y: 25 },
            { id: 4, type: 'circle', color: 'green', x: 25, y: 75 }
        ]
    },
    {
        title: "Ascension",
        subtitle: "Rise above.",
        shapes: [
            { id: 1, type: 'triangle', color: 'yellow', x: 50, y: 20, rotation: 0 },
            { id: 2, type: 'triangle', color: 'blue', x: 50, y: 50, rotation: 180 },
            { id: 3, type: 'triangle', color: 'pink', x: 50, y: 80, rotation: 0 }
        ]
    },
    {
        title: "Chaos",
        subtitle: "Order from disorder.",
        shapes: [
            { id: 1, type: 'circle', color: 'blue', x: 20, y: 20 },
            { id: 2, type: 'circle', color: 'yellow', x: 80, y: 80 },
            { id: 3, type: 'square', color: 'green', x: 80, y: 20 },
            { id: 4, type: 'square', color: 'pink', x: 20, y: 80 },
            { id: 5, type: 'triangle', color: 'blue', x: 50, y: 50, rotation: 45 }
        ]
    },
    {
        title: "Alignment",
        subtitle: "Everything in its place.",
        shapes: [
            { id: 1, type: 'square', color: 'yellow', x: 20, y: 50 },
            { id: 2, type: 'triangle', color: 'pink', x: 40, y: 50, rotation: 90 },
            { id: 3, type: 'circle', color: 'green', x: 60, y: 50 },
            { id: 4, type: 'square', color: 'blue', x: 80, y: 50 }
        ]
    },
    {
        title: "Zenith",
        subtitle: "Reach for the peak.",
        shapes: [
            { id: 1, type: 'triangle', color: 'green', x: 50, y: 25, rotation: 0 },
            { id: 2, type: 'triangle', color: 'green', x: 30, y: 60, rotation: -45 },
            { id: 3, type: 'triangle', color: 'green', x: 70, y: 60, rotation: 45 },
            { id: 4, type: 'circle', color: 'yellow', x: 50, y: 50 }
        ]
    },
    {
        title: "Harmony",
        subtitle: "Perfect resonance.",
        shapes: [
            { id: 1, type: 'square', color: 'blue', x: 35, y: 35 },
            { id: 2, type: 'square', color: 'pink', x: 65, y: 65 },
            { id: 3, type: 'circle', color: 'yellow', x: 65, y: 35 },
            { id: 4, type: 'circle', color: 'green', x: 35, y: 65 },
            { id: 5, type: 'triangle', color: 'blue', x: 50, y: 50, rotation: 180 }
        ]
    },
    {
        title: "Complexity",
        subtitle: "Embrace the challenge.",
        shapes: [
            { id: 1, type: 'square', color: 'yellow', x: 25, y: 25 },
            { id: 2, type: 'square', color: 'blue', x: 75, y: 75 },
            { id: 3, type: 'triangle', color: 'pink', x: 75, y: 25, rotation: -90 },
            { id: 4, type: 'triangle', color: 'green', x: 25, y: 75, rotation: 90 },
            { id: 5, type: 'circle', color: 'blue', x: 50, y: 50 }
        ]
    },
    {
        title: "Rhythm",
        subtitle: "Feel the flow.",
        shapes: [
            { id: 1, type: 'circle', color: 'pink', x: 20, y: 50 },
            { id: 2, type: 'circle', color: 'pink', x: 40, y: 50 },
            { id: 3, type: 'circle', color: 'pink', x: 60, y: 50 },
            { id: 4, type: 'circle', color: 'pink', x: 80, y: 50 },
            { id: 5, type: 'triangle', color: 'yellow', x: 50, y: 20, rotation: 180 },
            { id: 6, type: 'triangle', color: 'yellow', x: 50, y: 80, rotation: 0 }
        ]
    },
    {
        title: "Symmetry",
        subtitle: "Reflect on beauty.",
        shapes: [
            { id: 1, type: 'square', color: 'blue', x: 50, y: 50 },
            { id: 2, type: 'circle', color: 'green', x: 30, y: 30 },
            { id: 3, type: 'circle', color: 'green', x: 70, y: 70 },
            { id: 4, type: 'triangle', color: 'yellow', x: 70, y: 30, rotation: 45 },
            { id: 5, type: 'triangle', color: 'yellow', x: 30, y: 70, rotation: -135 }
        ]
    },
    {
        title: "Transcendence",
        subtitle: "Beyond the form.",
        shapes: [
            { id: 1, type: 'circle', color: 'pink', x: 50, y: 20 },
            { id: 2, type: 'square', color: 'blue', x: 80, y: 50 },
            { id: 3, type: 'triangle', color: 'green', x: 50, y: 80, rotation: 0 },
            { id: 4, type: 'circle', color: 'yellow', x: 20, y: 50 },
            { id: 5, type: 'square', color: 'pink', x: 50, y: 50 }
        ]
    }
];

const QUOTES = [
    "Breathing in, I calm body and mind. Breathing out, I smile.",
    "The present moment is filled with joy and happiness.",
    "Feelings come and go like clouds in a windy sky. Conscious breathing is my anchor.",
    "Peace comes from within. Do not seek it without.",
    "Quiet the mind, and the soul will speak.",
    "Simplicity is the ultimate sophistication.",
    "Nature does not hurry, yet everything is accomplished.",
    "The best way to capture moments is to pay attention."
];

class SoundEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; // Gentle volume
        this.masterGain.connect(this.ctx.destination);
    }

    resume() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, startTime = 0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);

        gain.gain.setValueAtTime(0, this.ctx.currentTime + startTime);
        gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + startTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.start(this.ctx.currentTime + startTime);
        osc.stop(this.ctx.currentTime + startTime + duration + 0.1);
    }

    play(sound) {
        this.resume();
        const now = this.ctx.currentTime;

        switch (sound) {
            case 'pickup':
                // High blip
                this.playTone(600, 'sine', 0.1);
                this.playTone(800, 'sine', 0.1, 0.05);
                break;
            case 'hover':
                // Subtle tick
                this.playTone(400, 'triangle', 0.05);
                break;
            case 'drop_success':
                // Harmonious Major Triad (C Majorish)
                this.playTone(523.25, 'sine', 0.4); // C5
                this.playTone(659.25, 'sine', 0.4, 0.05); // E5
                this.playTone(783.99, 'sine', 0.6, 0.1); // G5
                break;
            case 'drop_fail':
                // Dull thud
                this.playTone(200, 'triangle', 0.2);
                this.playTone(150, 'sine', 0.2, 0.05);
                break;
            case 'win':
                // Arpeggio
                [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((freq, i) => {
                    this.playTone(freq, 'sine', 0.5, i * 0.08);
                });
                break;
        }
    }
}

class Game {
    constructor() {
        this.levelIndex = 0;
        this.currentLevel = null;
        this.placedCount = 0;
        this.mistakes = 0;

        this.sound = new SoundEngine();

        // DOM Elements
        this.canvas = document.getElementById('game-canvas');
        this.palette = document.getElementById('palette');
        this.levelDisplay = document.getElementById('level-display');
        this.overlay = document.getElementById('completion-overlay');
        this.btnNext = document.getElementById('btn-next');
        this.btnReplay = document.getElementById('btn-replay');
        this.tutorialHint = document.getElementById('tutorial-hint');
        this.winTitle = document.getElementById('win-title');
        this.winStats = document.getElementById('win-stats');
        this.btnSound = document.getElementById('btn-sound');

        // Drag State
        this.dragItem = null;
        this.dragGhost = null;
        this.dragData = null;
        this.isDragging = false;

        // Physics State
        this.pointerPos = { x: 0, y: 0 };
        this.ghostPos = { x: 0, y: 0 };
        this.ghostVel = { x: 0, y: 0 };
        this.targetSnap = null;

        // Idle Timer
        this.idleTimer = null;

        this.init();
    }

    init() {
        this.btnNext.addEventListener('click', () => {
             this.sound.resume(); // Ensure audio context starts on user interaction
             this.nextLevel();
        });

        this.btnReplay.addEventListener('click', () => {
             this.sound.resume();
             this.loadLevel(this.levelIndex);
        });

        this.loadLevel(this.levelIndex);

        // Global Pointer Events for Dragging
        window.addEventListener('pointermove', (e) => this.onPointerMove(e));
        window.addEventListener('pointerup', (e) => this.onPointerUp(e));
        window.addEventListener('pointercancel', (e) => this.onPointerUp(e));

        // Resume audio on first touch
        window.addEventListener('pointerdown', () => this.sound.resume(), { once: true });

        // Reset idle timer on interaction
        ['pointerdown', 'pointermove', 'keydown'].forEach(evt => {
            window.addEventListener(evt, () => this.resetIdleTimer());
        });

        this.resetIdleTimer();

        // Sound Toggle
        this.btnSound.addEventListener('click', () => this.toggleSound());
        this.updateSoundIcon();
    }

    toggleSound() {
        this.sound.enabled = !this.sound.enabled;
        this.updateSoundIcon();
        if (this.sound.enabled) {
            this.sound.resume();
            this.sound.play('pickup');
        }
    }

    updateSoundIcon() {
        const path = this.sound.enabled
            ? "M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"
            : "M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z";

        this.btnSound.querySelector('svg').innerHTML = `<path d="${path}"/>`;
        this.btnSound.style.opacity = this.sound.enabled ? '1' : '0.5';
    }

    resetIdleTimer() {
        clearTimeout(this.idleTimer);
        this.idleTimer = setTimeout(() => this.showHint(), 6000); // 6 seconds idle
    }

    showHint() {
        const targets = Array.from(this.canvas.querySelectorAll('.target:not(.filled)'));
        if (targets.length === 0) return;

        const target = targets[0];
        const targetId = parseInt(target.dataset.id);

        const paletteItems = Array.from(this.palette.children);
        const match = paletteItems.find(item => {
            if(!item.dataset.shape) return false;
            const data = JSON.parse(item.dataset.shape);
            return data.id === targetId;
        });

        if (match) {
            match.classList.add('shake-element');
            setTimeout(() => match.classList.remove('shake-element'), 500);
        }
    }

    loadLevel(index) {
        this.levelIndex = index;
        this.currentLevel = LEVELS[this.levelIndex % LEVELS.length];
        this.placedCount = 0;
        this.mistakes = 0;
        this.startTime = Date.now();

        // Enhanced Level Display
        this.levelDisplay.innerHTML = `
            <span style="opacity:0.6">${this.levelIndex + 1} / ${LEVELS.length}</span>
            <span style="margin: 0 6px; opacity: 0.3">|</span>
            ${this.currentLevel.title || 'Puzzle'}
        `;
        this.overlay.classList.remove('visible');

        // Tutorial / Subtitle Logic
        this.tutorialHint.classList.remove('visible');

        if (this.levelIndex === 0) {
            this.tutorialHint.textContent = "Drag shapes to match";
            this.tutorialHint.classList.add('visible');
        } else if (this.currentLevel.subtitle) {
            // Show subtitle briefly
            this.tutorialHint.textContent = this.currentLevel.subtitle;
            this.tutorialHint.classList.add('visible');
            setTimeout(() => {
                if(this.placedCount === 0) this.tutorialHint.classList.remove('visible');
            }, 4000);
        }

        this.canvas.innerHTML = '';
        this.palette.innerHTML = '';

        // Render Targets
        this.currentLevel.shapes.forEach(shape => {
            const el = document.createElement('div');
            el.className = `shape target type-${shape.type} color-${shape.color}`;
            el.dataset.id = shape.id;
            el.style.left = `${shape.x}%`;
            el.style.top = `${shape.y}%`;
            el.style.transform = `translate(-50%, -50%) ${shape.rotation ? `rotate(${shape.rotation}deg)` : ''}`;

            const render = document.createElement('div');
            render.className = 'shape-render';
            el.appendChild(render);

            this.canvas.appendChild(el);
        });

        // Render Palette
        const shuffled = [...this.currentLevel.shapes].sort(() => Math.random() - 0.5);
        shuffled.forEach(shape => {
            // Create a slot for visual structure
            const slot = document.createElement('div');
            slot.className = 'palette-slot';
            this.palette.appendChild(slot);

            const el = document.createElement('div');
            el.className = `shape in-palette type-${shape.type} color-${shape.color}`;
            el.setAttribute('role', 'button');
            el.setAttribute('tabindex', '0');
            el.setAttribute('aria-label', `${shape.color} ${shape.type}`);

            // Initial position inside slot (visually)
            // We'll append it to palette, but we need to ensure it sits over the slot.
            // Actually, we can append it to the palette but position it absolute relative to palette for dragging?
            // No, the original code had them in flow.
            // To keep "slots", we append slot, then put shape inside slot?
            // If shape is inside slot, `position: absolute` in `.shape` might break if slot is relative.
            // Let's modify `.shape.in-palette` to be relative or absolute.
            // Current css: `.shape` is absolute. `.palette` is flex.
            // If we put shape inside slot, slot is static/relative in flex. Shape is absolute.

            slot.appendChild(el);
            // Ensure shape is centered in slot
            el.style.left = '50%';
            el.style.top = '50%';
            el.style.transform = 'translate(-50%, -50%)';
            el.style.position = 'absolute';

            const render = document.createElement('div');
            render.className = 'shape-render';
            el.appendChild(render);
            el.dataset.shape = JSON.stringify(shape);
            el.addEventListener('pointerdown', (e) => this.onDragStart(e, el, shape));
        });

        // Add Tutorial Hand for Level 1
        if (this.levelIndex === 0) {
            this.showTutorialHand();
        }
    }

    showTutorialHand() {
        const hand = document.createElement('div');
        hand.className = 'hand-cursor animating';

        // Find first shape in palette to start from
        const firstSlot = this.palette.querySelector('.palette-slot');
        if(!firstSlot) return;

        // Position roughly over the first shape
        // We will append to palette to be safe with z-index
        this.palette.appendChild(hand);

        // Let CSS animation handle the movement illusion
        // Or we can try to position it dynamically. CSS is safer for performance.
        hand.style.left = '32px';
        hand.style.top = '32px';

        this.tutorialHand = hand;
    }

    onDragStart(e, element, data) {
        e.preventDefault();
        if(this.isDragging) return;

        this.dragItem = element;
        this.dragData = data;
        this.isTouch = e.pointerType === 'touch' || (e.touches && e.touches.length > 0);

        this.pointerPos = { x: e.clientX, y: e.clientY };
        this.ghostPos = { x: e.clientX, y: e.clientY };
        this.ghostVel = { x: 0, y: 0 };
        this.targetSnap = null;

        if (navigator.vibrate) navigator.vibrate(10);
        this.sound.play('pickup');

        // Create Ghost
        this.dragGhost = element.cloneNode(true);
        this.dragGhost.classList.remove('in-palette');
        this.dragGhost.classList.add('drag-ghost');

        // Handle rotation visually on inner element if needed, preserve existing transform
        if (data.rotation) {
             const render = this.dragGhost.querySelector('.shape-render');
             if(render) render.style.transform = `rotate(${data.rotation}deg)`;
        }

        document.body.appendChild(this.dragGhost);
        this.dragItem.classList.add('dragging');
        this.tutorialHint.classList.remove('visible'); // Hide hint on interaction

        if(this.tutorialHand) {
            this.tutorialHand.remove();
            this.tutorialHand = null;
        }

        this.isDragging = true;
        this.dragLoop();
    }

    onPointerMove(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        this.pointerPos.x = e.clientX;
        this.pointerPos.y = e.clientY;

        // Check magnet
        this.checkHover();
    }

    checkHover() {
        const targets = Array.from(this.canvas.querySelectorAll('.target'));
        let closest = null;
        let minDist = 60; // Snap radius

        targets.forEach(target => {
            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(this.pointerPos.x - centerX, this.pointerPos.y - centerY);

            const wasHighlighted = target.classList.contains('highlight');
            target.classList.remove('highlight');

            if (dist < minDist && parseInt(target.dataset.id) === this.dragData.id && !target.classList.contains('filled')) {
                closest = { el: target, x: centerX, y: centerY };
                target.classList.add('highlight');

                // Play sound on enter
                if (!wasHighlighted) {
                     this.sound.play('hover');
                     if(navigator.vibrate) navigator.vibrate(5);
                }
            }
        });

        this.targetSnap = closest;
    }

    dragLoop() {
        if(!this.isDragging) return;
        requestAnimationFrame(() => this.dragLoop());

        // Physics Constants
        const spring = 0.15;
        const damping = 0.75;

        // Target: Mouse or Snap Center
        let targetX = this.pointerPos.x;
        let targetY = this.pointerPos.y;

        // Mobile Offset
        let visualOffsetY = this.isTouch ? -80 : 0;

        if (this.targetSnap) {
            targetX = this.targetSnap.x;
            targetY = this.targetSnap.y;
            // When snapped, remove mobile offset to show it locking in place?
            // Or keep offset? Usually lock in place.
            visualOffsetY = 0;
        }

        const forceX = (targetX - this.ghostPos.x) * spring;
        const forceY = (targetY - (this.ghostPos.y - visualOffsetY)) * spring;

        this.ghostVel.x = (this.ghostVel.x + forceX) * damping;
        this.ghostVel.y = (this.ghostVel.y + forceY) * damping;

        this.ghostPos.x += this.ghostVel.x;
        this.ghostPos.y += this.ghostVel.y;

        // Tilt based on horizontal velocity
        const maxTilt = 20;
        const tilt = Math.max(Math.min(this.ghostVel.x * 2.5, maxTilt), -maxTilt);

        // Scale effect when snapped
        const scale = this.targetSnap ? 1.0 : 1.15;

        if(this.dragGhost) {
            this.dragGhost.style.transform = `translate(${this.ghostPos.x}px, ${this.ghostPos.y}px) rotate(${tilt}deg) scale(${scale})`;
        }
    }

    onPointerUp(e) {
        if (!this.isDragging) return;

        this.isDragging = false; // Stop loop

        // Drop logic: use the Magnet target if exists, otherwise mouse check
        let dropped = false;

        if (this.targetSnap) {
             this.placeShape(this.targetSnap.el);
             dropped = true;
        } else {
            dropped = this.attemptDrop(e.clientX, e.clientY);
        }

        if (dropped) {
            this.dragItem.remove();
            if(this.dragGhost) this.dragGhost.remove();
            this.placedCount++;

            if (this.placedCount === this.currentLevel.shapes.length) {
                this.handleWin();
            } else {
                this.sound.play('drop_success');
                this.showFloatingFeedback(this.targetSnap.el, "Snap!");
            }
            if (navigator.vibrate) navigator.vibrate(20);
        } else {
            this.mistakes++;
            this.dragItem.classList.remove('dragging');
            this.sound.play('drop_fail');

            // Animate fail back
            if(this.dragGhost) {
                this.dragGhost.style.transition = 'transform 0.4s var(--ease-spring), opacity 0.3s';
                this.dragGhost.style.opacity = '0';

                // Optional: Move it back to original rect? Too complex for now, fade out is fine.
                // We could transform it to the palette position.
                const rect = this.dragItem.getBoundingClientRect();
                this.dragGhost.style.transform = `translate(${rect.left + 32}px, ${rect.top + 32}px) scale(0.5)`;

                const ghost = this.dragGhost;
                setTimeout(() => ghost.remove(), 400);
            }
            if (navigator.vibrate) navigator.vibrate([10, 50, 10]);
        }

        this.dragItem = null;
        this.dragGhost = null;
        this.dragData = null;
        this.targetSnap = null;

        document.querySelectorAll('.target.highlight').forEach(el => el.classList.remove('highlight'));
    }

    attemptDrop(x, y) {
        const targets = Array.from(this.canvas.querySelectorAll('.target'));

        for (let target of targets) {
            // Skip already placed
            if(target.classList.contains('filled')) continue;

            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(x - centerX, y - centerY);

            // Threshold for drop (40px radius)
            if (dist < 40) {
                // Check ID match
                if (parseInt(target.dataset.id) === this.dragData.id) {
                    return this.placeShape(target);
                }
            }
        }
        return false;
    }

    showFloatingFeedback(targetElement, text) {
        const feedback = document.createElement('div');
        feedback.className = 'feedback-text';
        feedback.textContent = text;

        const rect = targetElement.getBoundingClientRect();
        feedback.style.left = (rect.left + rect.width / 2) + 'px';
        feedback.style.top = (rect.top + rect.height / 2) + 'px';

        document.body.appendChild(feedback);
        setTimeout(() => feedback.remove(), 1000);
    }

    placeShape(target) {
        // Visual fill
        const placed = document.createElement('div');
        placed.className = `shape placed type-${this.dragData.type} color-${this.dragData.color}`;
        placed.style.left = target.style.left;
        placed.style.top = target.style.top;
        placed.style.transform = target.style.transform;

        const render = document.createElement('div');
        render.className = 'shape-render';
        placed.appendChild(render);

        this.canvas.appendChild(placed);

        // Hide target visually
        target.style.opacity = 0;
        target.classList.add('filled');

        // Check if palette is empty to show state?
        // Actually, we remove items from palette.

        // Sound effect placeholder (Visual pop is handled by CSS)
        if (navigator.vibrate) navigator.vibrate(20);

        return true;
    }

    handleWin() {
        const endTime = Date.now();
        const duration = ((endTime - this.startTime) / 1000).toFixed(1);
        const accuracy = Math.max(0, 100 - (this.mistakes * 15));

        // Dynamic praise based on performance
        let phrase = "Beautiful";
        if (accuracy === 100 && duration < 10) phrase = "Perfect Flow";
        else if (accuracy === 100) phrase = "Sublime Focus";
        else if (accuracy >= 80) phrase = "Geometric Harmony";
        else phrase = "Mindful Progress";

        this.winTitle.textContent = phrase;

        // Quote Logic
        const quote = QUOTES[Math.floor(Math.random() * QUOTES.length)];
        let quoteEl = document.getElementById('win-quote');
        if (!quoteEl) {
            quoteEl = document.createElement('p');
            quoteEl.id = 'win-quote';
            quoteEl.className = 'win-quote';
            this.winStats.parentNode.insertBefore(quoteEl, this.winStats);
        }
        quoteEl.textContent = `"${quote}"`;

        this.winStats.innerHTML = `
            <div style="display: flex; gap: 20px; justify-content: center; align-items: center;">
                <span title="Time taken">⏱ ${duration}s</span>
                <span title="Precision" style="opacity: ${accuracy === 100 ? 1 : 0.7}">🎯 ${accuracy}%</span>
            </div>
        `;

        setTimeout(() => {
            this.sound.play('win');
            this.overlay.classList.add('visible');
            this.fireConfetti();
        }, 500);
    }

    nextLevel() {
        this.loadLevel(this.levelIndex + 1);
    }

    fireConfetti() {
        // High Quality Confetti
        const colors = ['#007AFF', '#FF2D55', '#34C759', '#FFCC00', '#5856D6', '#FF9500'];
        const particleCount = 60;

        const createParticle = () => {
            const conf = document.createElement('div');
            conf.style.position = 'fixed';
            conf.style.left = '50%';
            conf.style.top = '50%';
            conf.style.width = Math.random() > 0.5 ? '8px' : '12px';
            conf.style.height = Math.random() > 0.5 ? '8px' : '6px';
            conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            conf.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
            conf.style.zIndex = '2000';
            conf.style.pointerEvents = 'none';
            document.body.appendChild(conf);

            const angle = Math.random() * Math.PI * 2;
            const velocity = 3 + Math.random() * 6;
            const tx = Math.cos(angle) * velocity * 120; // Spread radius
            const ty = Math.sin(angle) * velocity * 120;
            const rotation = Math.random() * 1080;

            // Physics simulation (gravity)
            const anim = conf.animate([
                { transform: 'translate(0,0) rotate(0deg)', opacity: 1 },
                { transform: `translate(${tx}px, ${ty}px) rotate(${rotation * 0.5}deg)`, opacity: 1, offset: 0.6 },
                { transform: `translate(${tx}px, ${ty + 150}px) rotate(${rotation}deg)`, opacity: 0 }
            ], {
                duration: 1200 + Math.random() * 800,
                easing: 'cubic-bezier(0.25, 1, 0.5, 1)'
            });

            anim.onfinish = () => conf.remove();
        };

        // Burst
        for(let i=0; i<particleCount; i++) {
            setTimeout(createParticle, Math.random() * 200);
        }

        // Secondary burst
        setTimeout(() => {
             for(let i=0; i<particleCount/2; i++) createParticle();
        }, 300);
    }
}

// Start Game
document.addEventListener('DOMContentLoaded', () => {
    new Game();
});

})();
</script>
</body>
</html>
