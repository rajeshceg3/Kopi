<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#f5f5f7">
    <meta name="description" content="A world-class shape matching puzzle game.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://your-app-url.com/">
    <meta property="og:title" content="Kop朝">
    <meta property="og:description" content="A world-class shape matching puzzle game.">
    <meta property="og:image" content="https://your-app-url.com/kopi-og-image.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://your-app-url.com/">
    <meta property="twitter:title" content="Kop朝">
    <meta property="twitter:description" content="A world-class shape matching puzzle game.">
    <meta property="twitter:image" content="https://your-app-url.com/kopi-og-image.png">

    <title>Kop朝</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            /* World Class Color Palette */
            --bg-primary: #f5f5f7;
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;

            /* Vibrant, Tactile Colors - P3 Gamut inspired */
            --color-blue: #007AFF;
            --color-pink: #FF2D55;
            --color-green: #34C759;
            --color-yellow: #FFCC00;

            /* Deep, layered shadows for depth */
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04), 0 1px 2px rgba(0,0,0,0.06);
            --shadow-md: 0 12px 24px -6px rgba(0,0,0,0.08), 0 4px 8px -4px rgba(0,0,0,0.04);
            --shadow-lg: 0 24px 48px -12px rgba(0,0,0,0.12), 0 12px 24px -8px rgba(0,0,0,0.04);
            --shadow-float: 0 30px 60px -12px rgba(50, 50, 93, 0.25), 0 18px 36px -18px rgba(0, 0, 0, 0.3);

            --shadow-inner: inset 0 1px 1px rgba(255,255,255,0.5), inset 0 -2px 5px rgba(0,0,0,0.05);
            --shadow-glass: 0 8px 32px 0 rgba(31, 38, 135, 0.07);

            --radius-md: 20px;
            --radius-lg: 36px;
            --radius-full: 999px;

            /* Animation curves */
            --ease-elastic: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-smooth: cubic-bezier(0.2, 0.0, 0.2, 1.0);
            --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.35);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f7;
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Noise Texture for Texture/Premium Feel */
        .noise-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9000;
            opacity: 0.035;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* Subtle animated background mesh */
        body::before {
            content: '';
            position: absolute;
            width: 140%;
            height: 140%;
            background: radial-gradient(circle at 50% 10%, rgba(0,122,255,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 90% 60%, rgba(255,45,85,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 10% 70%, rgba(52,199,89,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 80% 20%, rgba(255,204,0,0.05) 0%, transparent 30%);
            top: -20%;
            left: -20%;
            z-index: -1;
            animation: floatBg 20s ease-in-out infinite alternate;
            will-change: transform;
        }

        @keyframes floatBg {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(-2%, 2%) scale(1.05); }
        }

        /* Layout Container */
        .app-container {
            width: 100%;
            height: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            padding: 24px;
            position: relative;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 4px;
            margin-bottom: 16px;
            z-index: 10;
        }

        .logo {
            opacity: 0.9;
            height: 32px;
        }

        .logo svg {
            height: 32px;
            width: auto;
            display: block;
        }

        .level-badge {
            background: rgba(255, 255, 255, 0.5);
            padding: 8px 16px;
            border-radius: var(--radius-full);
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-sm);
            letter-spacing: -0.3px;
            transition: transform 0.3s var(--ease-spring);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.5);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .control-btn:hover {
            transform: scale(1.1);
            color: var(--text-primary);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
        }

        .tooltip {
            position: relative;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 160px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 150%;
            left: 50%;
            margin-left: -80px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Game Area */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
            /* Provide some padding for the floating elements */
            padding: 20px 0;
        }

        .canvas-container {
            width: 100%;
            max-width: 420px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.45);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md), inset 0 0 0 1px rgba(255,255,255,0.6);
            position: relative;
            overflow: hidden;
            transition: transform 0.4s var(--ease-smooth);
        }

        /* Mobile Optimization */
        @media (max-width: 480px) {
            .app-container { padding: 16px; }
            .canvas-container { width: 92vw; border-radius: 28px; }
            .palette { border-radius: 28px; gap: 16px; padding: 16px; }
        }

        /* Palette (Dock) */
        .palette {
            margin-top: auto;
            width: 100%;
            min-height: 110px;
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-lg);
            padding: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            box-shadow: var(--shadow-lg), inset 0 0 0 1px rgba(255,255,255,0.5);
            position: relative;
            z-index: 20;
            margin-bottom: 24px;
            transition: transform 0.3s ease;
        }

        /* Shapes */
        .shape {
            width: 64px;
            height: 64px;
            position: absolute;
            will-change: transform;
            /* Default transform for centering if needed, but we position by top/left % */
        }

        /* Shape Rendering */
        .shape-render {
            width: 100%;
            height: 100%;
            /* Squircle approximation */
            border-radius: 22%;
            transition: transform 0.4s var(--ease-elastic), opacity 0.2s ease, filter 0.2s ease, box-shadow 0.3s ease;
            box-shadow: var(--shadow-inner), 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        /* Add a subtle sheen to shapes */
        .shape-render::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .shape.in-palette {
            position: relative;
            cursor: grab;
            touch-action: none;
            transition: transform 0.3s var(--ease-spring);
            z-index: 10;
        }

        /* Desktop Hover: Juicy scale and tilt handled by CSS for initial feel */
        @media (hover: hover) {
            .shape.in-palette:hover {
                transform: translateY(-8px) scale(1.1);
                z-index: 20;
            }
            .shape.in-palette:hover .shape-render {
                box-shadow: var(--shadow-float), var(--shadow-inner);
            }
        }

        .shape.in-palette:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .shape.in-palette .shape-render {
            box-shadow: 0 4px 10px rgba(0,0,0,0.1), var(--shadow-inner);
        }

        .shape.in-palette.dragging {
            opacity: 0.0; /* Fully hide original when dragging for better illusion */
        }

        /* Shape Types */
        .type-circle .shape-render { border-radius: 50%; }

        .type-triangle .shape-render {
            clip-path: polygon(50% 10%, 10% 85%, 90% 85%);
            border-radius: 0;
            box-shadow: none;
            background-color: transparent !important; /* Fix for bg bleed */
            /* Use filter for drop shadow on clipped shapes */
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
        }
        /* Triangle sheen fix */
        .type-triangle .shape-render::after {
            background: linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 60%);
        }

        /* Colors with slight gradient for depth */
        .color-blue .shape-render { background: linear-gradient(145deg, #2b95ff, #0066d6); }
        .color-pink .shape-render { background: linear-gradient(145deg, #ff5274, #e01640); }
        .color-green .shape-render { background: linear-gradient(145deg, #5ddb7d, #24b348); }
        .color-yellow .shape-render { background: linear-gradient(145deg, #ffd633, #eebb00); }

        /* Targets */
        .target {
            position: absolute;
            width: 64px;
            height: 64px;
            opacity: 1; /* Handle opacity in children */
            transform-origin: center;
            transition: transform 0.3s var(--ease-smooth);
        }

        .target .shape-render {
            background: rgba(0,0,0,0.04);
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            border: 2px solid rgba(0,0,0,0.05);
        }

        .target .shape-render::after { display: none; } /* No sheen on targets */

        .target.highlight .shape-render {
            background: rgba(0,0,0,0.08);
            border-color: rgba(0,0,0,0.1);
            transform: scale(1.1);
        }

        /* Placed Shape */
        .shape.placed {
            pointer-events: none;
        }
        .shape.placed .shape-render {
            animation: popIn 0.5s var(--ease-elastic) forwards;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Drag Ghost */
        .drag-ghost {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
            will-change: transform;
            width: 64px;
            height: 64px;
            margin-left: -32px; /* Center on pointer */
            margin-top: -32px;
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.25));
        }

        .drag-ghost .shape-render {
            transform: scale(1.15); /* Slightly larger while dragging */
        }

        /* Overlay */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 50;
            border-radius: var(--radius-lg);
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            background: linear-gradient(135deg, #1d1d1f 0%, #4a4a4f 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s var(--ease-smooth);
        }

        .overlay.visible h2 {
            transform: translateY(0);
            opacity: 1;
        }

        .btn-next {
            background: var(--text-primary);
            color: white;
            border: none;
            padding: 14px 32px;
            font-size: 16px;
            font-weight: 600;
            border-radius: var(--radius-full);
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s var(--ease-smooth) 0.1s;
        }
        
        .btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }

        .overlay.visible .btn-next {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Shake Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-6px); }
            40% { transform: translateX(6px); }
            60% { transform: translateX(-3px); }
            80% { transform: translateX(3px); }
        }
        
        .shake-element {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

    </style>
</head>
<body>
<div class="noise-overlay"></div>
<div class="app-container">
    <header class="header">
        <div class="logo">
            <svg width="68" height="32" viewBox="0 0 68 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12.8359 0.9375C11.1094 0.9375 9.6875 1.34375 8.57031 2.15625C7.45312 2.96875 6.64062 4.04688 6.13281 5.39062C5.625 6.73438 5.37109 8.21875 5.37109 9.84375V22.1562C5.37109 23.7812 5.625 25.2656 6.13281 26.6094C6.64062 27.9531 7.45312 29.0312 8.57031 29.8438C9.6875 30.6562 11.1094 31.0625 12.8359 31.0625H14.1641V27.5312H12.8359C11.8906 27.5312 11.1406 27.25 10.5859 26.6875C10.0312 26.125 9.75391 25.2812 9.75391 24.1562V7.84375C9.75391 6.71875 10.0312 5.875 10.5859 5.3125C11.1406 4.75 11.8906 4.46875 12.8359 4.46875H14.1641V0.9375H12.8359Z" fill="#1D1D1F"/>
                <path d="M26.2483 0.9375C24.3108 0.9375 22.764 1.48438 21.6077 2.57812C20.4514 3.67188 19.8733 5.17188 19.8733 7.07812V24.9219C19.8733 26.8281 20.4514 28.3281 21.6077 29.4219C22.764 30.5156 24.3108 31.0625 26.2483 31.0625C28.1858 31.0625 29.7327 30.5156 30.889 29.4219C32.0452 28.3281 32.6233 26.8281 32.6233 24.9219V7.07812C32.6233 5.17188 32.0452 3.67188 30.889 2.57812C29.7327 1.48438 28.1858 0.9375 26.2483 0.9375ZM26.2483 4.46875C27.1936 4.46875 27.928 4.75 28.4514 5.3125C28.9749 5.875 29.2366 6.71875 29.2366 7.84375V24.1562C29.2366 25.2812 28.9749 26.125 28.4514 26.6875C27.928 27.25 27.1936 27.5312 26.2483 27.5312C25.303 27.5312 24.5686 27.25 24.0452 26.6875C23.5217 26.125 23.26 25.2812 23.26 24.1562V7.84375C23.26 6.71875 23.5217 5.875 24.0452 5.3125C24.5686 4.75 25.303 4.46875 26.2483 4.46875Z" fill="#1D1D1F"/>
                <path d="M40.9167 4.46875H44.6042V21.4375L52.8854 4.46875H57.1771L48.8125 21.625V31H44.6042V21.5L40.9167 4.46875Z" fill="#1D1D1F"/>
                <path d="M60.6719 0.9375V31H64.9219V0.9375H60.6719Z" fill="#1D1D1F"/>
            </svg>
        </div>
        <div class="header-controls">
            <div class="level-badge" id="level-display">Level 1</div>
            <button class="control-btn" id="reset-btn" aria-label="Reset Level">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4.755 4.755a.75.75 0 011.06 0l1.673 1.673c1.332-1.331 3.16-2.178 5.132-2.178 4.08 0 7.447 3.367 7.447 7.447s-3.367 7.447-7.447 7.447-7.447-3.367-7.447-7.447c0-1.972.847-3.8 2.178-5.132L5.815 5.815a.75.75 0 010-1.06zm9.293 2.245a.75.75 0 01.191 1.045l-3.528 4.63a.75.75 0 01-1.142-.08L7.02 9.5a.75.75 0 111.218-.894l1.623 2.206 2.923-3.842a.75.75 0 011.045-.191z"></path></svg>
            </button>
            <button class="control-btn" id="sound-toggle-btn" aria-label="Toggle Sound">
                <svg id="sound-on-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14.764 2.236a.75.75 0 00-.764.132L8.536 7.5H4.75A2.25 2.25 0 002.5 9.75v4.5A2.25 2.25 0 004.75 16.5h3.786l5.464 5.132a.75.75 0 001.132-.884L14.5 12 15.132 2.75a.75.75 0 00-.368-.514zM16.5 7.969a.75.75 0 00-1.06 1.06 3 3 0 010 6A.75.75 0 1016.5 16a4.5 4.5 0 000-8.03z"></path><path d="M18.803 5.697a.75.75 0 00-1.06 1.061 6 6 0 010 10.5a.75.75 0 101.06 1.06 7.5 7.5 0 000-12.622z"></path></svg>
                <svg id="sound-off-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: none;"><path d="M14.764 2.236a.75.75 0 00-.764.132L8.536 7.5H4.75A2.25 2.25 0 002.5 9.75v4.5A2.25 2.25 0 004.75 16.5h3.786l5.464 5.132a.75.75 0 001.132-.884L14.5 12 15.132 2.75a.75.75 0 00-.368-.514z"></path><path d="M19.58 12.83a.75.75 0 01-1.06 1.06l-1.61-1.61-1.61 1.61a.75.75 0 11-1.06-1.06l1.61-1.61-1.61-1.61a.75.75 0 111.06-1.06l1.61 1.61 1.61-1.61a.75.75 0 111.06 1.06l-1.61 1.61 1.61 1.61z"></path></svg>
            </button>
            <div class="tooltip">
                <button class="control-btn" id="help-btn" aria-label="Help">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm0 1.5a8.25 8.25 0 100 16.5 8.25 8.25 0 000-16.5zM12 10.5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5a.75.75 0 01.75-.75zM12 8.25a.75.75 0 110-1.5.75.75 0 010 1.5z"></path></svg>
                </button>
                <span class="tooltip-text">Drag the shapes from the bottom palette to their matching targets.</span>
            </div>
        </div>
    </header>

    <div class="game-area">
        <div class="canvas-container" id="canvas-container">
            <div id="game-canvas" style="width: 100%; height: 100%; position: relative;"></div>

            <div class="overlay" id="completion-overlay">
                <h2>Perfect</h2>
                <button class="btn-next" id="btn-next">Continue</button>
            </div>
        </div>
    </div>

    <div class="palette" id="palette">
        <!-- Palette Items Generated Here -->
    </div>
</div>

<script>
/**
 * Kop朝 - World Class UX Polish
 * Optimized for Touch (Mobile) and Mouse (Desktop)
 */

(() => {
const LEVELS = [
    { shapes: [{ id: 1, type: 'square', color: 'blue', x: 20, y: 40 }, { id: 2, type: 'circle', color: 'pink', x: 65, y: 40 }] },
    { shapes: [{ id: 1, type: 'square', color: 'green', x: 25, y: 20 }, { id: 2, type: 'circle', color: 'yellow', x: 60, y: 60 }, { id: 3, type: 'triangle', color: 'blue', x: 25, y: 60, rotation: 0 }] },
    { shapes: [{ id: 1, type: 'square', color: 'blue', x: 20, y: 20 }, { id: 2, type: 'square', color: 'blue', x: 68, y: 20 }, { id: 3, type: 'circle', color: 'pink', x: 44, y: 44 }, { id: 4, type: 'triangle', color: 'yellow', x: 44, y: 68, rotation: 180 }] },
    { shapes: [{ id: 1, type: 'triangle', color: 'green', x: 50, y: 25, rotation: 0 }, { id: 2, type: 'triangle', color: 'green', x: 50, y: 65, rotation: 180 }, { id: 3, type: 'square', color: 'yellow', x: 25, y: 45 }, { id: 4, type: 'square', color: 'pink', x: 75, y: 45 }] },
    { shapes: [{ id: 1, type: 'circle', color: 'blue', x: 50, y: 50 }, { id: 2, type: 'square', color: 'pink', x: 50, y: 20 }, { id: 3, type: 'square', color: 'pink', x: 50, y: 80 }, { id: 4, type: 'square', color: 'pink', x: 20, y: 50 }, { id: 5, type: 'square', color: 'pink', x: 80, y: 50 }] },
    { shapes: [{ id: 1, type: 'triangle', color: 'yellow', x: 50, y: 50, rotation: 60 }, { id: 2, type: 'triangle', color: 'yellow', x: 50, y: 50, rotation: 180 }, { id: 3, type: 'triangle', color: 'yellow', x: 50, y: 50, rotation: 300 }] },
    { shapes: [{ id: 1, type: 'square', color: 'green', x: 20, y: 20 }, { id: 2, type: 'square', color: 'blue', x: 80, y: 20 }, { id: 3, type: 'square', color: 'pink', x: 20, y: 80 }, { id: 4, type: 'square', color: 'yellow', x: 80, y: 80 }, { id: 5, type: 'circle', color: 'blue', x: 50, y: 50 }] },
    { shapes: [{ id: 1, type: 'circle', color: 'pink', x: 25, y: 25 }, { id: 2, type: 'circle', color: 'pink', x: 75, y: 25 }, { id: 3, type: 'circle', color: 'pink', x: 25, y: 75 }, { id: 4, type: 'circle', color: 'pink', x: 75, y: 75 }, { id: 5, type: 'square', color: 'green', x: 50, y: 50 }, { id: 6, type: 'triangle', color: 'blue', x: 50, y: 25, rotation: 180 }, { id: 7, type: 'triangle', color: 'blue', x: 50, y: 75, rotation: 0 }] }
];

const COMPLETION_MESSAGES = ['Perfect', 'Brilliant', 'Fantastic', 'Well Done', 'Amazing', 'Superb'];

class SoundEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; // Gentle volume
        this.masterGain.connect(this.ctx.destination);
    }

    resume() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    toggle() {
        this.enabled = !this.enabled;
        this.masterGain.gain.setValueAtTime(this.enabled ? 0.3 : 0, this.ctx.currentTime);
        return this.enabled;
    }

    playTone(freq, type, duration, startTime = 0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);

        gain.gain.setValueAtTime(0, this.ctx.currentTime + startTime);
        gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + startTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.start(this.ctx.currentTime + startTime);
        osc.stop(this.ctx.currentTime + startTime + duration + 0.1);
    }

    play(sound) {
        this.resume();
        const now = this.ctx.currentTime;

        switch (sound) {
            case 'pickup':
                // High blip
                this.playTone(600, 'sine', 0.1);
                this.playTone(800, 'sine', 0.1, 0.05);
                break;
            case 'hover':
                // Subtle tick
                this.playTone(400, 'triangle', 0.05);
                break;
            case 'drop_success':
                // Harmonious Major Triad (C Majorish)
                this.playTone(523.25, 'sine', 0.4); // C5
                this.playTone(659.25, 'sine', 0.4, 0.05); // E5
                this.playTone(783.99, 'sine', 0.6, 0.1); // G5
                break;
            case 'drop_fail':
                // Dull thud
                this.playTone(200, 'triangle', 0.2);
                this.playTone(150, 'sine', 0.2, 0.05);
                break;
            case 'win':
                // Arpeggio
                [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((freq, i) => {
                    this.playTone(freq, 'sine', 0.5, i * 0.08);
                });
                break;
        }
    }
}

class Game {
    constructor() {
        this.levelIndex = 0;
        this.currentLevel = null;
        this.placedCount = 0;

        this.sound = new SoundEngine();

        // DOM Elements
        this.canvas = document.getElementById('game-canvas');
        this.palette = document.getElementById('palette');
        this.levelDisplay = document.getElementById('level-display');
        this.overlay = document.getElementById('completion-overlay');
        this.completionText = this.overlay.querySelector('h2');
        this.btnNext = document.getElementById('btn-next');
        this.soundToggleBtn = document.getElementById('sound-toggle-btn');
        this.soundOnIcon = document.getElementById('sound-on-icon');
        this.soundOffIcon = document.getElementById('sound-off-icon');
        this.resetBtn = document.getElementById('reset-btn');

        // Drag State
        this.dragItem = null;
        this.dragGhost = null;
        this.dragData = null;
        this.isDragging = false;

        // Physics State
        this.pointerPos = { x: 0, y: 0 };
        this.ghostPos = { x: 0, y: 0 };
        this.ghostVel = { x: 0, y: 0 };
        this.targetSnap = null;

        // Idle Timer
        this.idleTimer = null;

        this.init();
    }

    init() {
        this.btnNext.addEventListener('click', () => {
             this.sound.resume(); // Ensure audio context starts on user interaction
             this.nextLevel();
        });

        this.soundToggleBtn.addEventListener('click', () => {
            const isEnabled = this.sound.toggle();
            this.soundOnIcon.style.display = isEnabled ? 'block' : 'none';
            this.soundOffIcon.style.display = isEnabled ? 'none' : 'block';
        });

        this.resetBtn.addEventListener('click', () => {
            this.loadLevel(this.levelIndex);
        });

        this.loadLevel(this.levelIndex);

        // Global Pointer Events for Dragging
        window.addEventListener('pointermove', (e) => this.onPointerMove(e));
        window.addEventListener('pointerup', (e) => this.onPointerUp(e));
        window.addEventListener('pointercancel', (e) => this.onPointerUp(e));

        // Resume audio on first touch
        window.addEventListener('pointerdown', () => this.sound.resume(), { once: true });

        // Reset idle timer on interaction
        ['pointerdown', 'pointermove', 'keydown'].forEach(evt => {
            window.addEventListener(evt, () => this.resetIdleTimer());
        });

        this.resetIdleTimer();
    }

    resetIdleTimer() {
        clearTimeout(this.idleTimer);
        this.idleTimer = setTimeout(() => this.showHint(), 6000); // 6 seconds idle
    }

    showHint() {
        const targets = Array.from(this.canvas.querySelectorAll('.target:not(.filled)'));
        if (targets.length === 0) return;

        const target = targets[0];
        const targetId = parseInt(target.dataset.id);

        const paletteItems = Array.from(this.palette.children);
        const match = paletteItems.find(item => {
            if(!item.dataset.shape) return false;
            const data = JSON.parse(item.dataset.shape);
            return data.id === targetId;
        });

        if (match) {
            match.classList.add('shake-element');
            setTimeout(() => match.classList.remove('shake-element'), 500);
        }
    }

    loadLevel(index) {
        this.levelIndex = index;
        this.currentLevel = LEVELS[this.levelIndex % LEVELS.length];
        this.placedCount = 0;

        this.levelDisplay.textContent = `Level ${this.levelIndex + 1}`;
        this.overlay.classList.remove('visible');

        this.canvas.innerHTML = '';
        this.palette.innerHTML = '';

        // Render Targets
        this.currentLevel.shapes.forEach(shape => {
            const el = document.createElement('div');
            el.className = `shape target type-${shape.type} color-${shape.color}`;
            el.dataset.id = shape.id;
            el.style.left = `${shape.x}%`;
            el.style.top = `${shape.y}%`;
            el.style.transform = `translate(-50%, -50%) ${shape.rotation ? `rotate(${shape.rotation}deg)` : ''}`;

            const render = document.createElement('div');
            render.className = 'shape-render';
            el.appendChild(render);

            this.canvas.appendChild(el);
        });

        // Render Palette
        const shuffled = [...this.currentLevel.shapes].sort(() => Math.random() - 0.5);
        shuffled.forEach(shape => {
            const el = document.createElement('div');
            el.className = `shape in-palette type-${shape.type} color-${shape.color}`;
            el.setAttribute('role', 'button');
            el.setAttribute('tabindex', '0');
            el.setAttribute('aria-label', `${shape.color} ${shape.type}`);

            const render = document.createElement('div');
            render.className = 'shape-render';
            el.appendChild(render);
            el.dataset.shape = JSON.stringify(shape);
            el.addEventListener('pointerdown', (e) => this.onDragStart(e, el, shape));
            this.palette.appendChild(el);
        });
    }

    onDragStart(e, element, data) {
        e.preventDefault();
        if(this.isDragging) return;

        this.dragItem = element;
        this.dragData = data;
        this.isTouch = e.pointerType === 'touch' || (e.touches && e.touches.length > 0);

        this.pointerPos = { x: e.clientX, y: e.clientY };
        this.ghostPos = { x: e.clientX, y: e.clientY };
        this.ghostVel = { x: 0, y: 0 };
        this.targetSnap = null;

        if (navigator.vibrate) navigator.vibrate(10);
        this.sound.play('pickup');

        // Create Ghost
        this.dragGhost = element.cloneNode(true);
        this.dragGhost.classList.remove('in-palette');
        this.dragGhost.classList.add('drag-ghost');

        // Handle rotation visually on inner element if needed, preserve existing transform
        if (data.rotation) {
             const render = this.dragGhost.querySelector('.shape-render');
             if(render) render.style.transform = `rotate(${data.rotation}deg)`;
        }

        document.body.appendChild(this.dragGhost);
        this.dragItem.classList.add('dragging');

        this.isDragging = true;
        this.dragLoop();
    }

    onPointerMove(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        this.pointerPos.x = e.clientX;
        this.pointerPos.y = e.clientY;

        // Check magnet
        this.checkHover();
    }

    checkHover() {
        const targets = Array.from(this.canvas.querySelectorAll('.target'));
        let closest = null;
        let minDist = 60; // Snap radius

        targets.forEach(target => {
            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(this.pointerPos.x - centerX, this.pointerPos.y - centerY);

            const wasHighlighted = target.classList.contains('highlight');
            target.classList.remove('highlight');

            if (dist < minDist && parseInt(target.dataset.id) === this.dragData.id && !target.classList.contains('filled')) {
                closest = { el: target, x: centerX, y: centerY };
                target.classList.add('highlight');

                // Play sound on enter
                if (!wasHighlighted) {
                     this.sound.play('hover');
                     if(navigator.vibrate) navigator.vibrate(5);
                }
            }
        });

        this.targetSnap = closest;
    }

    dragLoop() {
        if(!this.isDragging) return;
        requestAnimationFrame(() => this.dragLoop());

        // Physics Constants
        const spring = 0.15;
        const damping = 0.75;

        // Target: Mouse or Snap Center
        let targetX = this.pointerPos.x;
        let targetY = this.pointerPos.y;

        // Mobile Offset
        let visualOffsetY = this.isTouch ? -80 : 0;

        if (this.targetSnap) {
            targetX = this.targetSnap.x;
            targetY = this.targetSnap.y;
            // When snapped, remove mobile offset to show it locking in place?
            // Or keep offset? Usually lock in place.
            visualOffsetY = 0;
        }

        const forceX = (targetX - this.ghostPos.x) * spring;
        const forceY = (targetY - (this.ghostPos.y - visualOffsetY)) * spring;

        this.ghostVel.x = (this.ghostVel.x + forceX) * damping;
        this.ghostVel.y = (this.ghostVel.y + forceY) * damping;

        this.ghostPos.x += this.ghostVel.x;
        this.ghostPos.y += this.ghostVel.y;

        // Tilt based on horizontal velocity
        const maxTilt = 20;
        const tilt = Math.max(Math.min(this.ghostVel.x * 2.5, maxTilt), -maxTilt);

        // Scale effect when snapped
        const scale = this.targetSnap ? 1.0 : 1.15;

        if(this.dragGhost) {
            this.dragGhost.style.transform = `translate(${this.ghostPos.x}px, ${this.ghostPos.y}px) rotate(${tilt}deg) scale(${scale})`;
        }
    }

    onPointerUp(e) {
        if (!this.isDragging) return;

        this.isDragging = false; // Stop loop

        // Drop logic: use the Magnet target if exists, otherwise mouse check
        let dropped = false;

        if (this.targetSnap) {
             this.placeShape(this.targetSnap.el);
             dropped = true;
        } else {
            dropped = this.attemptDrop(e.clientX, e.clientY);
        }

        if (dropped) {
            this.dragItem.remove();
            if(this.dragGhost) this.dragGhost.remove();
            this.placedCount++;

            if (this.placedCount === this.currentLevel.shapes.length) {
                this.handleWin();
            } else {
                this.sound.play('drop_success');
            }
            if (navigator.vibrate) navigator.vibrate(20);
        } else {
            this.dragItem.classList.remove('dragging');
            this.sound.play('drop_fail');

            // Animate fail back
            if(this.dragGhost) {
                this.dragGhost.style.transition = 'transform 0.4s var(--ease-spring), opacity 0.3s';
                this.dragGhost.style.opacity = '0';

                // Optional: Move it back to original rect? Too complex for now, fade out is fine.
                // We could transform it to the palette position.
                const rect = this.dragItem.getBoundingClientRect();
                this.dragGhost.style.transform = `translate(${rect.left + 32}px, ${rect.top + 32}px) scale(0.5)`;

                const ghost = this.dragGhost;
                setTimeout(() => ghost.remove(), 400);
            }
            if (navigator.vibrate) navigator.vibrate([10, 50, 10]);
        }

        this.dragItem = null;
        this.dragGhost = null;
        this.dragData = null;
        this.targetSnap = null;

        document.querySelectorAll('.target.highlight').forEach(el => el.classList.remove('highlight'));
    }

    attemptDrop(x, y) {
        const targets = Array.from(this.canvas.querySelectorAll('.target'));

        for (let target of targets) {
            // Skip already placed
            if(target.classList.contains('filled')) continue;

            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(x - centerX, y - centerY);

            // Threshold for drop (40px radius)
            if (dist < 40) {
                // Check ID match
                if (parseInt(target.dataset.id) === this.dragData.id) {
                    return this.placeShape(target);
                }
            }
        }
        return false;
    }

    placeShape(target) {
        // Visual fill
        const placed = document.createElement('div');
        placed.className = `shape placed type-${this.dragData.type} color-${this.dragData.color}`;
        placed.style.left = target.style.left;
        placed.style.top = target.style.top;
        placed.style.transform = target.style.transform;

        const render = document.createElement('div');
        render.className = 'shape-render';
        placed.appendChild(render);

        this.canvas.appendChild(placed);

        // Hide target visually
        target.style.opacity = 0;
        target.classList.add('filled');

        // Sound effect placeholder (Visual pop is handled by CSS)
        if (navigator.vibrate) navigator.vibrate(20);

        return true;
    }

    handleWin() {
        setTimeout(() => {
            const message = COMPLETION_MESSAGES[Math.floor(Math.random() * COMPLETION_MESSAGES.length)];
            this.completionText.textContent = message;
            this.sound.play('win');
            this.overlay.classList.add('visible');
            this.fireConfetti();
        }, 500);
    }

    nextLevel() {
        this.loadLevel(this.levelIndex + 1);
    }

    fireConfetti() {
        // High Quality Confetti
        const colors = ['#007AFF', '#FF2D55', '#34C759', '#FFCC00', '#5856D6', '#FF9500'];
        const particleCount = 60;

        const createParticle = () => {
            const conf = document.createElement('div');
            conf.style.position = 'fixed';
            conf.style.left = '50%';
            conf.style.top = '50%';
            conf.style.width = Math.random() > 0.5 ? '8px' : '12px';
            conf.style.height = Math.random() > 0.5 ? '8px' : '6px';
            conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            conf.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
            conf.style.zIndex = '2000';
            conf.style.pointerEvents = 'none';
            document.body.appendChild(conf);

            const angle = Math.random() * Math.PI * 2;
            const velocity = 3 + Math.random() * 6;
            const tx = Math.cos(angle) * velocity * 120; // Spread radius
            const ty = Math.sin(angle) * velocity * 120;
            const rotation = Math.random() * 1080;

            // Physics simulation (gravity)
            const anim = conf.animate([
                { transform: 'translate(0,0) rotate(0deg)', opacity: 1 },
                { transform: `translate(${tx}px, ${ty}px) rotate(${rotation * 0.5}deg)`, opacity: 1, offset: 0.6 },
                { transform: `translate(${tx}px, ${ty + 150}px) rotate(${rotation}deg)`, opacity: 0 }
            ], {
                duration: 1200 + Math.random() * 800,
                easing: 'cubic-bezier(0.25, 1, 0.5, 1)'
            });

            anim.onfinish = () => conf.remove();
        };

        // Burst
        for(let i=0; i<particleCount; i++) {
            setTimeout(createParticle, Math.random() * 200);
        }

        // Secondary burst
        setTimeout(() => {
             for(let i=0; i<particleCount/2; i++) createParticle();
        }, 300);
    }
}

// Start Game
document.addEventListener('DOMContentLoaded', () => {
    new Game();
});

})();
</script>
</body>
</html>
