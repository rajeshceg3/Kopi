<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#f5f5f7">
    <meta name="description" content="A world-class shape matching puzzle game.">
    <title>Kopī</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            /* World Class Color Palette */
            --bg-primary: #f5f5f7;
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;

            /* Vibrant, Tactile Colors - P3 Gamut inspired */
            --color-blue: #007AFF;
            --color-pink: #FF2D55;
            --color-green: #34C759;
            --color-yellow: #FFCC00;

            /* Deep, layered shadows for depth */
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04), 0 1px 2px rgba(0,0,0,0.06);
            --shadow-md: 0 12px 24px -6px rgba(0,0,0,0.08), 0 4px 8px -4px rgba(0,0,0,0.04);
            --shadow-lg: 0 24px 48px -12px rgba(0,0,0,0.12), 0 12px 24px -8px rgba(0,0,0,0.04);
            --shadow-float: 0 30px 60px -12px rgba(50, 50, 93, 0.25), 0 18px 36px -18px rgba(0, 0, 0, 0.3);

            --shadow-inner: inset 0 1px 1px rgba(255,255,255,0.5), inset 0 -2px 5px rgba(0,0,0,0.05);
            --shadow-glass: 0 8px 32px 0 rgba(31, 38, 135, 0.07);

            --radius-md: 20px;
            --radius-lg: 36px;
            --radius-full: 999px;

            /* Animation curves */
            --ease-elastic: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-smooth: cubic-bezier(0.2, 0.0, 0.2, 1.0);
            --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.35);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f7;
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Noise Texture for Texture/Premium Feel */
        .noise-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9000;
            opacity: 0.035;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* Subtle animated background mesh */
        body::before {
            content: '';
            position: absolute;
            width: 140%;
            height: 140%;
            background: radial-gradient(circle at 50% 10%, rgba(0,122,255,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 90% 60%, rgba(255,45,85,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 10% 70%, rgba(52,199,89,0.06) 0%, transparent 40%),
                        radial-gradient(circle at 80% 20%, rgba(255,204,0,0.05) 0%, transparent 30%);
            top: -20%;
            left: -20%;
            z-index: -1;
            animation: floatBg 20s ease-in-out infinite alternate;
            will-change: transform;
        }

        @keyframes floatBg {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(-2%, 2%) scale(1.05); }
        }

        /* Layout Container */
        .app-container {
            width: 100%;
            height: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            padding: 24px;
            position: relative;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 4px;
            margin-bottom: 16px;
            z-index: 10;
        }

        .logo {
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -1px;
            color: var(--text-primary);
            opacity: 0.9;
        }

        .level-badge {
            background: rgba(255, 255, 255, 0.5);
            padding: 8px 16px;
            border-radius: var(--radius-full);
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-sm);
            letter-spacing: -0.3px;
            transition: transform 0.3s var(--ease-spring);
        }

        /* Game Area */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
            /* Provide some padding for the floating elements */
            padding: 20px 0;
        }

        .canvas-container {
            width: 100%;
            max-width: 420px;
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.45);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md), inset 0 0 0 1px rgba(255,255,255,0.6);
            position: relative;
            overflow: hidden;
            transition: transform 0.4s var(--ease-smooth);
        }

        /* Mobile Optimization */
        @media (max-width: 480px) {
            .app-container { padding: 16px; }
            .canvas-container { width: 92vw; border-radius: 28px; }
            .palette { border-radius: 28px; gap: 16px; padding: 16px; }
        }

        /* Palette (Dock) */
        .palette {
            margin-top: auto;
            width: 100%;
            min-height: 110px;
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border-radius: var(--radius-lg);
            padding: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            box-shadow: var(--shadow-lg), inset 0 0 0 1px rgba(255,255,255,0.5);
            position: relative;
            z-index: 20;
            margin-bottom: 24px;
            transition: transform 0.3s ease;
        }

        /* Shapes */
        .shape {
            width: 64px;
            height: 64px;
            position: absolute;
            will-change: transform;
            /* Default transform for centering if needed, but we position by top/left % */
        }

        /* Shape Rendering */
        .shape-render {
            width: 100%;
            height: 100%;
            /* Squircle approximation */
            border-radius: 22%;
            transition: transform 0.4s var(--ease-elastic), opacity 0.2s ease, filter 0.2s ease, box-shadow 0.3s ease;
            box-shadow: var(--shadow-inner), 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        /* Add a subtle sheen to shapes */
        .shape-render::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }

        .shape.in-palette {
            position: relative;
            cursor: grab;
            touch-action: none;
            transition: transform 0.3s var(--ease-spring);
            z-index: 10;
        }

        /* Desktop Hover: Juicy scale and tilt handled by CSS for initial feel */
        @media (hover: hover) {
            .shape.in-palette:hover {
                transform: translateY(-8px) scale(1.1);
                z-index: 20;
            }
            .shape.in-palette:hover .shape-render {
                box-shadow: var(--shadow-float), var(--shadow-inner);
            }
        }

        .shape.in-palette:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .shape.in-palette .shape-render {
            box-shadow: 0 4px 10px rgba(0,0,0,0.1), var(--shadow-inner);
        }

        .shape.in-palette.dragging {
            opacity: 0.0; /* Fully hide original when dragging for better illusion */
        }

        /* Shape Types */
        .type-circle .shape-render { border-radius: 50%; }

        .type-triangle .shape-render {
            clip-path: polygon(50% 10%, 10% 85%, 90% 85%);
            border-radius: 0;
            box-shadow: none;
            background-color: transparent !important; /* Fix for bg bleed */
            /* Use filter for drop shadow on clipped shapes */
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
        }
        /* Triangle sheen fix */
        .type-triangle .shape-render::after {
            background: linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 60%);
        }

        /* Colors with slight gradient for depth */
        .color-blue .shape-render { background: linear-gradient(145deg, #2b95ff, #0066d6); }
        .color-pink .shape-render { background: linear-gradient(145deg, #ff5274, #e01640); }
        .color-green .shape-render { background: linear-gradient(145deg, #5ddb7d, #24b348); }
        .color-yellow .shape-render { background: linear-gradient(145deg, #ffd633, #eebb00); }

        /* Targets */
        .target {
            position: absolute;
            width: 64px;
            height: 64px;
            opacity: 1; /* Handle opacity in children */
            transform-origin: center;
            transition: transform 0.3s var(--ease-smooth);
        }

        .target .shape-render {
            background: rgba(0,0,0,0.04);
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            border: 2px solid rgba(0,0,0,0.05);
        }

        .target .shape-render::after { display: none; } /* No sheen on targets */

        .target.highlight .shape-render {
            background: rgba(0,0,0,0.08);
            border-color: rgba(0,0,0,0.1);
            transform: scale(1.1);
        }

        /* Placed Shape */
        .shape.placed {
            pointer-events: none;
        }
        .shape.placed .shape-render {
            animation: popIn 0.5s var(--ease-elastic) forwards;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Drag Ghost */
        .drag-ghost {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
            will-change: transform;
            width: 64px;
            height: 64px;
            margin-left: -32px; /* Center on pointer */
            margin-top: -32px;
            filter: drop-shadow(0 15px 30px rgba(0,0,0,0.25));
        }

        .drag-ghost .shape-render {
            transform: scale(1.15); /* Slightly larger while dragging */
        }

        /* Overlay */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 50;
            border-radius: var(--radius-lg);
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            background: linear-gradient(135deg, #1d1d1f 0%, #4a4a4f 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s var(--ease-smooth);
        }

        .overlay.visible h2 {
            transform: translateY(0);
            opacity: 1;
        }

        .btn-next {
            background: var(--text-primary);
            color: white;
            border: none;
            padding: 14px 32px;
            font-size: 16px;
            font-weight: 600;
            border-radius: var(--radius-full);
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s var(--ease-smooth) 0.1s;
        }
        
        .btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.3);
        }

        .overlay.visible .btn-next {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Shake Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-6px); }
            40% { transform: translateX(6px); }
            60% { transform: translateX(-3px); }
            80% { transform: translateX(3px); }
        }
        
        .shake-element {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

    </style>
</head>
<body>
<div class="noise-overlay"></div>
<div class="app-container">
    <header class="header">
        <div class="logo">Kopī</div>
        <div class="level-badge" id="level-display">Level 1</div>
    </header>

    <div class="game-area">
        <div class="canvas-container" id="canvas-container">
            <div id="game-canvas" style="width: 100%; height: 100%; position: relative;"></div>

            <div class="overlay" id="completion-overlay">
                <h2>Perfect</h2>
                <button class="btn-next" id="btn-next">Continue</button>
            </div>
        </div>
    </div>

    <div class="palette" id="palette">
        <!-- Palette Items Generated Here -->
    </div>
</div>

<script>
/**
 * Kopī - World Class UX Polish
 * Optimized for Touch (Mobile) and Mouse (Desktop)
 */

(() => {
const LEVELS = [
    { shapes: [{ id: 1, type: 'square', color: 'blue', x: 20, y: 40 }, { id: 2, type: 'circle', color: 'pink', x: 65, y: 40 }] },
    { shapes: [{ id: 1, type: 'square', color: 'green', x: 25, y: 20 }, { id: 2, type: 'circle', color: 'yellow', x: 60, y: 60 }, { id: 3, type: 'triangle', color: 'blue', x: 25, y: 60, rotation: 0 }] },
    { shapes: [{ id: 1, type: 'square', color: 'blue', x: 20, y: 20 }, { id: 2, type: 'square', color: 'blue', x: 68, y: 20 }, { id: 3, type: 'circle', color: 'pink', x: 44, y: 44 }, { id: 4, type: 'triangle', color: 'yellow', x: 44, y: 68, rotation: 180 }] }
];

class SoundEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; // Gentle volume
        this.masterGain.connect(this.ctx.destination);
    }

    resume() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, startTime = 0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);

        gain.gain.setValueAtTime(0, this.ctx.currentTime + startTime);
        gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + startTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.start(this.ctx.currentTime + startTime);
        osc.stop(this.ctx.currentTime + startTime + duration + 0.1);
    }

    play(sound) {
        this.resume();
        const now = this.ctx.currentTime;

        switch (sound) {
            case 'pickup':
                // High blip
                this.playTone(600, 'sine', 0.1);
                this.playTone(800, 'sine', 0.1, 0.05);
                break;
            case 'hover':
                // Subtle tick
                this.playTone(400, 'triangle', 0.05);
                break;
            case 'drop_success':
                // Harmonious Major Triad (C Majorish)
                this.playTone(523.25, 'sine', 0.4); // C5
                this.playTone(659.25, 'sine', 0.4, 0.05); // E5
                this.playTone(783.99, 'sine', 0.6, 0.1); // G5
                break;
            case 'drop_fail':
                // Dull thud
                this.playTone(200, 'triangle', 0.2);
                this.playTone(150, 'sine', 0.2, 0.05);
                break;
            case 'win':
                // Arpeggio
                [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((freq, i) => {
                    this.playTone(freq, 'sine', 0.5, i * 0.08);
                });
                break;
        }
    }
}

class Game {
    constructor() {
        this.levelIndex = 0;
        this.currentLevel = null;
        this.placedCount = 0;

        this.sound = new SoundEngine();

        // DOM Elements
        this.canvas = document.getElementById('game-canvas');
        this.palette = document.getElementById('palette');
        this.levelDisplay = document.getElementById('level-display');
        this.overlay = document.getElementById('completion-overlay');
        this.btnNext = document.getElementById('btn-next');

        // Drag State
        this.dragItem = null;
        this.dragGhost = null;
        this.dragData = null;
        this.isDragging = false;

        // Physics State
        this.pointerPos = { x: 0, y: 0 };
        this.ghostPos = { x: 0, y: 0 };
        this.ghostVel = { x: 0, y: 0 };
        this.targetSnap = null;

        // Idle Timer
        this.idleTimer = null;

        this.init();
    }

    init() {
        this.btnNext.addEventListener('click', () => {
             this.sound.resume(); // Ensure audio context starts on user interaction
             this.nextLevel();
        });

        this.loadLevel(this.levelIndex);

        // Global Pointer Events for Dragging
        window.addEventListener('pointermove', (e) => this.onPointerMove(e));
        window.addEventListener('pointerup', (e) => this.onPointerUp(e));
        window.addEventListener('pointercancel', (e) => this.onPointerUp(e));

        // Resume audio on first touch
        window.addEventListener('pointerdown', () => this.sound.resume(), { once: true });

        // Reset idle timer on interaction
        ['pointerdown', 'pointermove', 'keydown'].forEach(evt => {
            window.addEventListener(evt, () => this.resetIdleTimer());
        });

        this.resetIdleTimer();
    }

    resetIdleTimer() {
        clearTimeout(this.idleTimer);
        this.idleTimer = setTimeout(() => this.showHint(), 6000); // 6 seconds idle
    }

    showHint() {
        const targets = Array.from(this.canvas.querySelectorAll('.target:not(.filled)'));
        if (targets.length === 0) return;

        const target = targets[0];
        const targetId = parseInt(target.dataset.id);

        const paletteItems = Array.from(this.palette.children);
        const match = paletteItems.find(item => {
            if(!item.dataset.shape) return false;
            const data = JSON.parse(item.dataset.shape);
            return data.id === targetId;
        });

        if (match) {
            match.classList.add('shake-element');
            setTimeout(() => match.classList.remove('shake-element'), 500);
        }
    }

    loadLevel(index) {
        this.levelIndex = index;
        this.currentLevel = LEVELS[this.levelIndex % LEVELS.length];
        this.placedCount = 0;

        this.levelDisplay.textContent = `Level ${this.levelIndex + 1}`;
        this.overlay.classList.remove('visible');

        this.canvas.innerHTML = '';
        this.palette.innerHTML = '';

        // Render Targets
        this.currentLevel.shapes.forEach(shape => {
            const el = document.createElement('div');
            el.className = `shape target type-${shape.type} color-${shape.color}`;
            el.dataset.id = shape.id;
            el.style.left = `${shape.x}%`;
            el.style.top = `${shape.y}%`;
            el.style.transform = `translate(-50%, -50%) ${shape.rotation ? `rotate(${shape.rotation}deg)` : ''}`;

            const render = document.createElement('div');
            render.className = 'shape-render';
            el.appendChild(render);

            this.canvas.appendChild(el);
        });

        // Render Palette
        const shuffled = [...this.currentLevel.shapes].sort(() => Math.random() - 0.5);
        shuffled.forEach(shape => {
            const el = document.createElement('div');
            el.className = `shape in-palette type-${shape.type} color-${shape.color}`;
            el.setAttribute('role', 'button');
            el.setAttribute('tabindex', '0');
            el.setAttribute('aria-label', `${shape.color} ${shape.type}`);

            const render = document.createElement('div');
            render.className = 'shape-render';
            el.appendChild(render);
            el.dataset.shape = JSON.stringify(shape);
            el.addEventListener('pointerdown', (e) => this.onDragStart(e, el, shape));
            this.palette.appendChild(el);
        });
    }

    onDragStart(e, element, data) {
        e.preventDefault();
        if(this.isDragging) return;

        this.dragItem = element;
        this.dragData = data;
        this.isTouch = e.pointerType === 'touch' || (e.touches && e.touches.length > 0);

        this.pointerPos = { x: e.clientX, y: e.clientY };
        this.ghostPos = { x: e.clientX, y: e.clientY };
        this.ghostVel = { x: 0, y: 0 };
        this.targetSnap = null;

        if (navigator.vibrate) navigator.vibrate(10);
        this.sound.play('pickup');

        // Create Ghost
        this.dragGhost = element.cloneNode(true);
        this.dragGhost.classList.remove('in-palette');
        this.dragGhost.classList.add('drag-ghost');

        // Handle rotation visually on inner element if needed, preserve existing transform
        if (data.rotation) {
             const render = this.dragGhost.querySelector('.shape-render');
             if(render) render.style.transform = `rotate(${data.rotation}deg)`;
        }

        document.body.appendChild(this.dragGhost);
        this.dragItem.classList.add('dragging');

        this.isDragging = true;
        this.dragLoop();
    }

    onPointerMove(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        this.pointerPos.x = e.clientX;
        this.pointerPos.y = e.clientY;

        // Check magnet
        this.checkHover();
    }

    checkHover() {
        const targets = Array.from(this.canvas.querySelectorAll('.target'));
        let closest = null;
        let minDist = 60; // Snap radius

        targets.forEach(target => {
            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(this.pointerPos.x - centerX, this.pointerPos.y - centerY);

            const wasHighlighted = target.classList.contains('highlight');
            target.classList.remove('highlight');

            if (dist < minDist && parseInt(target.dataset.id) === this.dragData.id && !target.classList.contains('filled')) {
                closest = { el: target, x: centerX, y: centerY };
                target.classList.add('highlight');

                // Play sound on enter
                if (!wasHighlighted) {
                     this.sound.play('hover');
                     if(navigator.vibrate) navigator.vibrate(5);
                }
            }
        });

        this.targetSnap = closest;
    }

    dragLoop() {
        if(!this.isDragging) return;
        requestAnimationFrame(() => this.dragLoop());

        // Physics Constants
        const spring = 0.15;
        const damping = 0.75;

        // Target: Mouse or Snap Center
        let targetX = this.pointerPos.x;
        let targetY = this.pointerPos.y;

        // Mobile Offset
        let visualOffsetY = this.isTouch ? -80 : 0;

        if (this.targetSnap) {
            targetX = this.targetSnap.x;
            targetY = this.targetSnap.y;
            // When snapped, remove mobile offset to show it locking in place?
            // Or keep offset? Usually lock in place.
            visualOffsetY = 0;
        }

        const forceX = (targetX - this.ghostPos.x) * spring;
        const forceY = (targetY - (this.ghostPos.y - visualOffsetY)) * spring;

        this.ghostVel.x = (this.ghostVel.x + forceX) * damping;
        this.ghostVel.y = (this.ghostVel.y + forceY) * damping;

        this.ghostPos.x += this.ghostVel.x;
        this.ghostPos.y += this.ghostVel.y;

        // Tilt based on horizontal velocity
        const maxTilt = 20;
        const tilt = Math.max(Math.min(this.ghostVel.x * 2.5, maxTilt), -maxTilt);

        // Scale effect when snapped
        const scale = this.targetSnap ? 1.0 : 1.15;

        if(this.dragGhost) {
            this.dragGhost.style.transform = `translate(${this.ghostPos.x}px, ${this.ghostPos.y}px) rotate(${tilt}deg) scale(${scale})`;
        }
    }

    onPointerUp(e) {
        if (!this.isDragging) return;

        this.isDragging = false; // Stop loop

        // Drop logic: use the Magnet target if exists, otherwise mouse check
        let dropped = false;

        if (this.targetSnap) {
             this.placeShape(this.targetSnap.el);
             dropped = true;
        } else {
            dropped = this.attemptDrop(e.clientX, e.clientY);
        }

        if (dropped) {
            this.dragItem.remove();
            if(this.dragGhost) this.dragGhost.remove();
            this.placedCount++;

            if (this.placedCount === this.currentLevel.shapes.length) {
                this.handleWin();
            } else {
                this.sound.play('drop_success');
            }
            if (navigator.vibrate) navigator.vibrate(20);
        } else {
            this.dragItem.classList.remove('dragging');
            this.sound.play('drop_fail');

            // Animate fail back
            if(this.dragGhost) {
                this.dragGhost.style.transition = 'transform 0.4s var(--ease-spring), opacity 0.3s';
                this.dragGhost.style.opacity = '0';

                // Optional: Move it back to original rect? Too complex for now, fade out is fine.
                // We could transform it to the palette position.
                const rect = this.dragItem.getBoundingClientRect();
                this.dragGhost.style.transform = `translate(${rect.left + 32}px, ${rect.top + 32}px) scale(0.5)`;

                const ghost = this.dragGhost;
                setTimeout(() => ghost.remove(), 400);
            }
            if (navigator.vibrate) navigator.vibrate([10, 50, 10]);
        }

        this.dragItem = null;
        this.dragGhost = null;
        this.dragData = null;
        this.targetSnap = null;

        document.querySelectorAll('.target.highlight').forEach(el => el.classList.remove('highlight'));
    }

    attemptDrop(x, y) {
        const targets = Array.from(this.canvas.querySelectorAll('.target'));

        for (let target of targets) {
            // Skip already placed
            if(target.classList.contains('filled')) continue;

            const rect = target.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dist = Math.hypot(x - centerX, y - centerY);

            // Threshold for drop (40px radius)
            if (dist < 40) {
                // Check ID match
                if (parseInt(target.dataset.id) === this.dragData.id) {
                    return this.placeShape(target);
                }
            }
        }
        return false;
    }

    placeShape(target) {
        // Visual fill
        const placed = document.createElement('div');
        placed.className = `shape placed type-${this.dragData.type} color-${this.dragData.color}`;
        placed.style.left = target.style.left;
        placed.style.top = target.style.top;
        placed.style.transform = target.style.transform;

        const render = document.createElement('div');
        render.className = 'shape-render';
        placed.appendChild(render);

        this.canvas.appendChild(placed);

        // Hide target visually
        target.style.opacity = 0;
        target.classList.add('filled');

        // Sound effect placeholder (Visual pop is handled by CSS)
        if (navigator.vibrate) navigator.vibrate(20);

        return true;
    }

    handleWin() {
        setTimeout(() => {
            this.sound.play('win');
            this.overlay.classList.add('visible');
            this.fireConfetti();
        }, 500);
    }

    nextLevel() {
        this.loadLevel(this.levelIndex + 1);
    }

    fireConfetti() {
        // High Quality Confetti
        const colors = ['#007AFF', '#FF2D55', '#34C759', '#FFCC00', '#5856D6', '#FF9500'];
        const particleCount = 60;

        const createParticle = () => {
            const conf = document.createElement('div');
            conf.style.position = 'fixed';
            conf.style.left = '50%';
            conf.style.top = '50%';
            conf.style.width = Math.random() > 0.5 ? '8px' : '12px';
            conf.style.height = Math.random() > 0.5 ? '8px' : '6px';
            conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            conf.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
            conf.style.zIndex = '2000';
            conf.style.pointerEvents = 'none';
            document.body.appendChild(conf);

            const angle = Math.random() * Math.PI * 2;
            const velocity = 3 + Math.random() * 6;
            const tx = Math.cos(angle) * velocity * 120; // Spread radius
            const ty = Math.sin(angle) * velocity * 120;
            const rotation = Math.random() * 1080;

            // Physics simulation (gravity)
            const anim = conf.animate([
                { transform: 'translate(0,0) rotate(0deg)', opacity: 1 },
                { transform: `translate(${tx}px, ${ty}px) rotate(${rotation * 0.5}deg)`, opacity: 1, offset: 0.6 },
                { transform: `translate(${tx}px, ${ty + 150}px) rotate(${rotation}deg)`, opacity: 0 }
            ], {
                duration: 1200 + Math.random() * 800,
                easing: 'cubic-bezier(0.25, 1, 0.5, 1)'
            });

            anim.onfinish = () => conf.remove();
        };

        // Burst
        for(let i=0; i<particleCount; i++) {
            setTimeout(createParticle, Math.random() * 200);
        }

        // Secondary burst
        setTimeout(() => {
             for(let i=0; i<particleCount/2; i++) createParticle();
        }, 300);
    }
}

// Start Game
document.addEventListener('DOMContentLoaded', () => {
    new Game();
});

})();
</script>
</body>
</html>
